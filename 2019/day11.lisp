;;;; day11.lisp

(in-package :aoc2019.day11)

(defun parse (input)
  (adjust-array (map 'vector #'parse-integer (str:split "," input)) 2048))

(defun run/c (memory)
  (let ((ip 0) (base 0) output)
    (labels ((run ()
               (macrolet ((ref (i) `(aref memory ,i))
                          (rel (offset) `(aref memory (+ ip ,offset)))
                          (bas (offset) `(aref memory (+ base ,offset))))
                 (symbol-macrolet ((opcode (rel 0))
                                   (ia (rel 1))
                                   (ib (rel 2))
                                   (ic (rel 3)))
                   (symbol-macrolet ((pa (ref ia)) (ba (bas ia))
                                     (pb (ref ib)) (bb (bas ib))
                                     (pc (ref ic)) (bc (bas ic)))
                     (labels ((mode (i) (mod (truncate opcode (expt 10 (1+ i))) 10))
                              (a () (ecase (mode 1) (0 pa) (1 ia) (2 ba)))
                              (b () (ecase (mode 2) (0 pb) (1 ib) (2 bb)))
                              (aa () (ecase (mode 1) (0 ia) (2 (+ ia base))))
                              (sc (x) (ecase (mode 3) (0 (setf pc x)) (2 (setf bc x))))
                              (jmp (x) (setf ip x) 0))
                       (loop with cont
                             do (incf ip (ecase (mod opcode 100)
                                           (1 (sc (+ (a) (b))) 4)
                                           (2 (sc (* (a) (b))) 4)
                                           (3 (setf cont (let ((address (aa)))
                                                           (lambda (x)
                                                             (setf (ref address) x)
                                                             (run))))
                                            2)
                                           (4 (push (a) output) 2)
                                           (5 (if (not (zerop (a))) (jmp (b)) 3))
                                           (6 (if (zerop (a)) (jmp (b)) 3))
                                           (7 (sc (if (< (a) (b)) 1 0)) 4)
                                           (8 (sc (if (= (a) (b)) 1 0)) 4)
                                           (9 (incf base (a)) 2)
                                           (99 (return (values nil output)))))
                             when cont return (values cont output))))))))
      (run))))

(defun add (a b) (mapcar #'+ a b))
(defun pos (x y) (list x y))
(defun x (p) (first p))
(defun y (p) (second p))
(defun right (d) (list (y d) (- (x d))))
(defun left (d) (list (- (y d)) (x d)))

(defun paint (robot &optional (start 0))
  (let ((colors (make-hash-table :test 'equal))
        (pos (pos 0 0))
        (d (pos 0 1)))
    (flet ((color () (gethash pos colors 0))
           (paint (color) (setf (gethash pos colors) color)))
      (paint start)
      (loop do (multiple-value-bind (next output) (funcall robot (color))
                 (destructuring-bind (turn color . rest) output
                   (declare (ignore rest))
                   (paint color)
                   (setf d (ecase turn
                             (0 (left d))
                             (1 (right d)))
                         pos (add pos d)
                         robot next)))
            while robot
            finally (return colors)))))

(defun part1 (input)
  (hash-table-count (paint (run/c (parse input)))))

(defun render (colors)
  (let* ((positions (a:hash-table-keys colors))
         (xs (mapcar #'x positions))
         (ys (mapcar #'y positions))
         (x1 (reduce #'min xs))
         (x2 (reduce #'max xs))
         (y1 (reduce #'max ys))
         (y2 (reduce #'min ys)))
    (loop for y from y1 downto y2
          for chars = (loop for x from x1 to x2
                            collect (aref " #" (gethash (pos x y) colors 0)))
          collect (coerce chars 'string))))

(defun part2 (input)
  (render (paint (run/c (parse input)) 1)))
