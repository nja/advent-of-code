;;;; day15.lisp

(in-package :aoc2019.day15)

(defun parse (input)
  (adjust-array (map 'vector #'parse-integer (str:split "," input)) 2048))

(defun run (memory input)
  (let ((ip 0) (base 0) output (input (list input)))
    (macrolet ((ref (i) `(aref memory ,i))
               (rel (offset) `(aref memory (+ ip ,offset)))
               (bas (offset) `(aref memory (+ base ,offset))))
      (symbol-macrolet ((opcode (rel 0))
                        (ia (rel 1))
                        (ib (rel 2))
                        (ic (rel 3)))
        (symbol-macrolet ((pa (ref ia)) (ba (bas ia))
                          (pb (ref ib)) (bb (bas ib))
                          (pc (ref ic)) (bc (bas ic)))
          (labels ((mode (i) (mod (truncate opcode (expt 10 (1+ i))) 10))
                   (a () (ecase (mode 1) (0 pa) (1 ia) (2 ba)))
                   (b () (ecase (mode 2) (0 pb) (1 ib) (2 bb)))
                   (sa (x) (ecase (mode 1) (0 (setf pa x)) (2 (setf ba x))))
                   (sc (x) (ecase (mode 3) (0 (setf pc x)) (2 (setf bc x))))
                   (jmp (x) (setf ip x) 0))
            (loop do (incf ip (ecase (mod opcode 100)
                                (1 (sc (+ (a) (b))) 4)
                                (2 (sc (* (a) (b))) 4)
                                (3 (sa (or (pop input) (error "No input"))) 2)
                                (4 (push (a) output) 2)
                                (5 (if (not (zerop (a))) (jmp (b)) 3))
                                (6 (if (zerop (a)) (jmp (b)) 3))
                                (7 (sc (if (< (a) (b)) 1 0)) 4)
                                (8 (sc (if (= (a) (b)) 1 0)) 4)
                                (9 (incf base (a)) 2)
                                (99 (return output))))
                  when output
                    return (pop output))))))))

(defun pos (x y) (list x y))
(defun add (a b) (mapcar #'+ a b))
(defparameter *directions* '((1 2) (2 1) (3 4) (4 3)))
(defun near (pos) (mapcar (a:curry #'add pos) '((0 1) (0 -1) (1 0) (-1 0))))

(defparameter *map* (make-hash-table))

(defun probe (droid dir)
  (destructuring-bind (cmd rcmd) dir
    (multiple-value-bind (status )
        (let ((status (funcall droid cmd)))
          (when (zerop status)
            (funcall droid rcmd))
          status))))

(defun droid (memory)
  (lambda (input)
    (let ((new-memory (copy-seq memory)))
      (list (funcall #'run new-memory input)
            (droid new-memory)))))

(defun neighbours (pos)
  (loop with droid = (gethash pos *map*)
        for p in (near pos)
        for c from 1
        for (status new-droid) = (funcall droid c)
        when (plusp status)
          do (setf (gethash p *map*) new-droid)
        when (eq status 2)
          collect 'oxygen
        when (eq status 1)
          collect p))

(defun fewest-steps (memory)
  (let ((*map* (make-hash-table))
        (origin '(0 0)))
    (setf (gethash origin *map*) (droid memory))
    (dijkstra:distance (dijkstra:search* origin #'neighbours :donep (a:curry #'eq 'oxygen)))))
