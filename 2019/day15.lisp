;;;; day15.lisp

(in-package :aoc2019.day15)

(defun parse (input)
  (adjust-array (map 'vector #'parse-integer (str:split "," input)) 2048))

(defun run (memory input)
  (let ((ip 0) (base 0) output)
    (macrolet ((ref (i) `(aref memory ,i))
               (rel (offset) `(aref memory (+ ip ,offset)))
               (bas (offset) `(aref memory (+ base ,offset))))
      (symbol-macrolet ((opcode (rel 0))
                        (ia (rel 1))
                        (ib (rel 2))
                        (ic (rel 3)))
        (symbol-macrolet ((pa (ref ia)) (ba (bas ia))
                          (pb (ref ib)) (bb (bas ib))
                          (pc (ref ic)) (bc (bas ic)))
          (labels ((mode (i) (mod (truncate opcode (expt 10 (1+ i))) 10))
                   (a () (ecase (mode 1) (0 pa) (1 ia) (2 ba)))
                   (b () (ecase (mode 2) (0 pb) (1 ib) (2 bb)))
                   (sa (x) (ecase (mode 1) (0 (setf pa x)) (2 (setf ba x))))
                   (sc (x) (ecase (mode 3) (0 (setf pc x)) (2 (setf bc x))))
                   (jmp (x) (setf ip x) 0))
            (loop do (incf ip (ecase (mod opcode 100)
                                (1 (sc (+ (a) (b))) 4)
                                (2 (sc (* (a) (b))) 4)
                                (3 (sa input) 2)
                                (4 (setf output (a)) 2)
                                (5 (if (not (zerop (a))) (jmp (b)) 3))
                                (6 (if (zerop (a)) (jmp (b)) 3))
                                (7 (sc (if (< (a) (b)) 1 0)) 4)
                                (8 (sc (if (= (a) (b)) 1 0)) 4)
                                (9 (incf base (a)) 2)
                                (99 (return output))))
                  when output return it)))))))

(defun pos (x y) (list x y))
(defun add (a b) (mapcar #'+ a b))
(defun near (pos) (mapcar (a:curry #'add pos) '((0 1) (0 -1) (1 0) (-1 0))))

(defun droid (memory)
  (lambda (input)
    (let ((copy (copy-seq memory)))
      (list (funcall #'run copy input)
            (droid copy)))))

(defun make-map (droid)
  (let ((map (make-hash-table :test 'equal))
        (origin '(0 0)))
    (setf (gethash origin map) (list 1 droid))
    (list map origin)))

(defun neighbours (map pos)
  (loop with droid = (second (gethash pos map))
        for p in (near pos)
        for c from 1
        for (status new-droid) = (funcall droid c)
        when (plusp status)
          do (setf (gethash p map) (list status new-droid))
          and collect p
        when (eq status 2)
          do (setf (gethash 'oxygen map) p)))

(defun fewest-steps (memory)
  (destructuring-bind (map origin) (make-map (droid memory))
    (dijkstra:distance (dijkstra:search* origin (a:curry #'neighbours map)
                                         :donep (lambda (p) (eq p (gethash 'oxygen map)))))))
(defun part1 (input)
  (fewest-steps (parse input)))

(defun map-area (memory)
  (destructuring-bind (map origin) (make-map (droid memory))
    (dijkstra:search* origin (a:curry #'neighbours map))
    map))

(defun how-many-minutes-to-fill-with-oxygen (map)
  (reduce #'max (mapcar #'dijkstra:distance (dijkstra:search* (gethash 'oxygen map) (a:curry #'neighbours map)))))

(defun part2 (input)
  (how-many-minutes-to-fill-with-oxygen (map-area (parse input))))
