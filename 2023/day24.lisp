;;;; day24.lisp

(in-package :aoc2023.day24)

(defstruct (ray :conc-name (:constructor ray (x y z dx dy dz)))
  x y z dx dy dz)

(defun parse (input)
  (mapcar (lambda (line)
            (apply #'ray (mapcar #'parse-integer (ppcre:all-matches-as-strings "-?\\d+" line))))
          (aoc:lines input)))

(defun 2d-intersect? (a b)
  (let ((dx (- (x b) (x a)))
        (dy (- (y b) (y a)))
        (det (- (* (dx b) (dy a))
                (* (dy b) (dx a)))))
    (unless (zerop det)
      (let ((u (/ (- (* dy (dx b))
                     (* dx (dy b)))
                  det))
            (v (/ (- (* dy (dx a))
                     (* dx (dy a)))
                  det)))
        (when (and (plusp u) (plusp v))
          (list (+ (x a) (* (dx a) u))
                (+ (y a) (* (dy a) u))))))))

(defun 2d-intersections (rays)
  (let (result)
    (a:map-combinations (lambda (x)
                          (a:when-let (p (apply #'2d-intersect? x))
                            (push p result)))
                        rays :length 2)
    result))

(defun bounds-predicate (x y)
  (lambda (point)
    (every (lambda (n) (<= x n y)) point)))

(defun part1 (input)
  (count-if (bounds-predicate 200000000000000 400000000000000)
            (2d-intersections (parse input))))

(defun equation-pair (h0 hn)
  (let ((a (x h0)) (b (x hn))
        (c (y h0)) (d (y hn))
        (e (dx h0)) (f (dx hn))
        (g (dy h0)) (h (dy hn))
        (i (z h0)) (j (z hn))
        (k (dz h0)) (l (dz hn)))
    (values (list (list (- g h) (- f e) 0 (- d c) (- a b) 0)
                  (list (- k l) 0 (- f e) (- j i) 0 (- a b)))
            (list (+ (* f d)
                     (* a g)
                     (- (* e c))
                     (- (* b h)))
                  (+ (* f j)
                     (* a k)
                     (- (* e i))
                     (- (* b l)))))))

(defun equation-system (h0 h1 h2 h3)
  (let (coefficients constants)
    (mapc (lambda (x)
            (multiple-value-bind (cs ts) (equation-pair h0 x)
              (setf coefficients (append coefficients cs)
                    constants (append constants ts))))
          (list h1 h2 h3))
    (values coefficients constants)))

(defun part2 (input)
  (let ((hails (subseq (parse input) 0 4)))
    (destructuring-bind (x y z dx dy dz) (multiple-value-call #'lalg:cramers (apply #'equation-system hails))
      (declare (ignore dx dy dz))
      (reduce #'+ (list x y z)))))
