;;;; day12.lisp

(in-package :aoc2023.day12)

(defun parse-line (line)
  (destructuring-bind (pattern counts) (str:split " " line)
    (list pattern (mapcar #'parse-integer (str:split "," counts)))))

(defun parse (input)
  (mapcar #'parse-line (aoc:lines input)))

(defun arrangements (counts length)
  (labels ((str (c l) (make-string l :initial-element c))
           (broken () (str #\# (first counts)))
           (spacer () (if (rest counts) "." ""))
           (required-length () (+ (max 0 (1- (length (rest counts)))) (reduce #'+ counts) (length (spacer)))))
    (cond ((null counts) (list (str #\. length)))
          ((> (required-length) length) nil)
          (t (let ((prefix (str:concat (broken) (spacer))))
               (append (mapcar (a:curry #'str:concat prefix) (arrangements (rest counts) (- length (length prefix))))
                       (mapcar (a:curry #'str:concat ".") (arrangements counts (1- length)))))))))

(defun count-valid-arrangements (pattern counts)
  (count-if (pattern-predicate pattern) (arrangements counts (length pattern))))

(defun pattern-predicate (pattern)
  (lambda (s)
    (every (lambda (p x) (or (char= #\? p) (char= p x))) pattern s)))

(defun part1 (input)
  (reduce #'+ (mapcar (a:curry #'apply #'count-valid-arrangements) (parse input))))

(defun unfold (record)
  (flet ((five (x) (loop repeat 5 collect x)))
    (list (format nil "~{~a~^?~}" (five (first record)))
          (apply #'append (five (second record))))))

(defun arrs2 (pattern counts)
  (let ((counts (coerce counts 'vector))
        (cache (make-array (list (+ 2 (length pattern)) (1+ (length counts))) :initial-element nil)))
    (labels ((rec* (pix cix)
               (or (aref cache pix cix)
                   (setf (aref cache pix cix)
                         (rec pix cix))))
             (rec (pix cix)
               (labels ((c () (aref counts cix))
                        (p (i) (and (array-in-bounds-p pattern i)
                                    (aref pattern i)))
                        (broken? (i) (find (p i) "#?"))
                        (empty? (i) (find (p i) ".?"))
                        (end? (i) (or (empty? i) (null (p i))))
                        (fits? () (and (loop for i from pix
                                             repeat (c)
                                             always (broken? i))
                                       (end? (+ pix (c)))))
                        (next-pix () (+ pix (c) 1)))
                 (cond ((= (length counts) cix)
                        (if (loop for i from pix below (length pattern)
                                  always (empty? i))
                            1
                            0))
                       ((<= (length pattern) pix)
                        0)
                       ((case (aref pattern pix)
                          (#\. (rec* (1+ pix) cix))
                          (#\# (if (fits?)
                                   (rec* (next-pix) (1+ cix))
                                   0))
                          (#\? (+ (if (fits?)
                                      (rec* (next-pix) (1+ cix))
                                      0)
                                  (rec* (1+ pix) cix)))))))))
      (rec 0 0))))

(defun part2 (input)
  (reduce #'+ (mapcar (lambda (x) (apply #'arrs2 (unfold x)))
                      (parse input))))
